this is new file
学习github网址： https://www.cnblogs.com/edisonchou/p/5990875.html

学习内存分析网址： https://www.cnblogs.com/InCerry/p/maoni-mem-doc.html#%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E6%8B%85%E5%BF%83
学习数据结构网址：https://www.cnblogs.com/edisonchou/p/4593972.html

线程管理：
线程都是在一个进程中会出现一些东西线程共享和线程不共享
线程共享内容：地址空间 全局变量 打开的文件 子进程 闹铃 信号以及信号服务程序 记账信息
线程独享内容：程序计数器 寄存器 栈 状态字


线程模型
说一个用户态和一个内核态不知道是什么东西先不关心

多线程的关系：
线程之间如何通信
线程之间如何同步
同步的原因和目的：
原因：上面说到线程可以共享变量,这样会产生竞态条件。所以需要同步。
同步就可以保证线程执行结果的确定性
同步方式：
一些必要概念
1.两个或者多个线程争相执行同一段代码或者访问同一资源被称为竞争
2.可能造成竞争的共享代码或者资源被称为临界区
3.在任何时刻都能有一个线程在临界区中的现象被称为互斥。（一次只有一个人使用共享资源，其他人皆排除在外）
4.锁
当两个教师都想使用同一个教室来为学生补课，如何协调呢？进到教室后将门锁上，另外一个教室就无法进来使用教室了。即教室是用锁来保证互斥的，那么在操作系统中，这种可以保证互斥的同步机制就被称为锁。


    下面是使用C#代码作为锁来控制
    private object locker = new object();
    public void Work()
    {
          lock (locker)
          {
              // 做一些需要线程同步的工作
          }
     }

锁有两个基本操作
锁有两个基本操作：闭锁和开锁。很容易理解，闭锁就是将锁锁上，其他人进不来；开锁就是你做的事情做完了，将锁打开，别的人可以进去了。开锁只有一个步骤那就是打开锁，而闭锁有两个步骤：一是等待锁达到打开状态，二是获得锁并锁上。显然，闭锁的两个操作应该是原子操作，不能分开。

　　② 睡觉与叫醒

　　当对方持有锁时，你就不需要等待锁变为打开状态，而是去睡觉，锁打开后对方再来把你叫醒，这是一种典型的生产者消费者模式。用计算机来模拟生产者消费者并不难：一个进程代表生产者，一个进程代表消费者，一片内存缓冲区代表商店。生产者将生产的物品从一端放入缓冲区，消费者则从另外一端获取物品，如下图所示：
  ![image](https://user-images.githubusercontent.com/43948693/191295563-b2f2d1e2-de39-4015-9b79-653b70d6a987.png)


接着学习这个文档：
https://www.cnblogs.com/lxblog/archive/2012/12/26/2833974.html

lock和Monitor.Enter(obj);Monitor.Exit(obj);是一样的。背后的代码就是这个.

Monitor.Enter是锁住该对象其他线程不可以访问，当Monitor.Exit的时候就会释放该对象.
  
